[üè° Inicio](../../index.html)

# Tema 1: Algunos principios b√°sicos de dise√±o orientado a objetos

## √çndice

- Modelado del software con UML
  
  - [Presentaci√≥n de UML](#Punto1)
  - [Modelado Estructural: Diagramas de Clases](#Punto2)
  - [Modelado del Comportamiento: Diagramas de Interacci√≥n](#Punto3)

- Patrones GRASPS y otros principios b√°sicos orientados a objetos
  
  - [Experto, Creador y Controlador](#Punto4)
  
  - [Principio de Separaci√≥n Modelo-Vista](#Punto5)
  
  - [T√©cnicas b√°sicas orientadas a objetos](#Punto6)

- Proceso de desarrollo de software
  
  - [M√©todos y t√©cnicas de creaci√≥n de software](#Punto7)
  
  - [Desarrollo dirigido por el dominio](#Punto8)

## Modelo

> Un modelo es una **representaci√≥n de la realidad** que es obtenido por medio de un proceso de [*abstracci√≥n*](#NotaAbstracci√≥n) con el prop√≥sito de ayudar a comprender y razonar sobre esa realidad. Un modelo es expresado en un ***lenguaje***.

> <a name="NotaAbstracci√≥n">**Abstracci√≥n**: </a> Se ignoran los detalles y nos centramos en las caracter√≠sticas esenciales que nos interesan.

Un modelo de software es una descripci√≥n abstracta de alg√∫n aspecto de los sistemas software, por ejemplo: los requistos, su estructura, el comportamiento, los datos, etc.

<img src="https://modeling-languages.com/wp-content/uploads/2014/04/historyModelingLanguages.jpg" title="" alt="" data-align="center">

## UML <a name="Punto1"></a>

A mediados de los a√±os noventa exist√≠an muchos m√©todos de an√°lisis y dise√±o orientado a objectos, sin embargo, sol√≠an ser los mismos conceptos expresados con notaciones diferentes, lo cual provocaba una gran confusi√≥n. En 1994, Grady Booch, James Rumbaugh e Ivar Jacobson deciden unificar las notaciones de sus m√©todos, dando as√≠ lugar al *Unified Modeling Language* (UML).

<img title="" src="https://s3.amazonaws.com/s3.timetoast.com/public/uploads/photo/11037302/image/10d1410f3b490a776792ef51ed0603d2" alt="" width="640" data-align="center">

Posteriormente, el lenguaje fue sometido a un proceso de estandarizaci√≥n promovido por el OMG (*Object Management Group*), una organizaci√≥n sin fines de lucro que cuida y promueve el uso de tecnolog√≠a orientada a objetos mediante gu√≠as y especificaciones.

Las ventajas de UML son:

¬†¬†¬†¬†‚úÖ Eliminar confusi√≥n.

¬†¬†¬†¬†‚úÖ Proporcionar estabilidad al mercado.

¬†¬†¬†¬†‚úÖ Reunir los puntos fuertes de cada m√©todo.

¬†¬†¬†¬†‚úÖ A√±adir mejoras. 

> **UML** es un lenguaje para visualizar, especificar, construir y documentar los ***modelos*** de un sistema software desde una perspectiva orientada a objetos.

<img title="" src="assets/ejemplo_diagrama_clase.png" alt="" data-align="inline" width="247"><img title="" src="assets/ejemplo_diagrama_secuencia.png" alt="diagrama_secuencia" width="324" data-align="inline">

*A la izquierda: ejemplo de diagrama de clase UML. A la derecha: ejemplo de diagrama de secuencia UML.*

Los modelos UML son √∫tiles para <u>documentar</u> decisiones de dise√±o e implementaci√≥n, para facilitar la <u>comunicaci√≥n</u> y los <u>razonamientos</u> gracias a su f√°cil visualizaci√≥n. Incluso pueden servir para la generaci√≥n de c√≥digo utilizando ciertas herramientas, pasando de ser modelos para documentar a ser modelos para generar el c√≥digo.

### Modelo vs. Diagrama

Un **modelo UML** es una <u>especificaci√≥n</u> de un aspecto del sistema de inter√©s para un grupo de usuarios o desarrolladores.

Un **diagrama UML** <u>representa</u> una parte de la informaci√≥n del modelo en forma gr√°fica o textual. En el diagrama de clases, por ejemplo, no aparecen todas las clases, atributos, m√©todos y asociaciones, sino solo aquellas que se consideran relevantes para el prop√≥sito.

![](assets/ejemplo_diagrama_clase.png)

### Uso del modelado UML

> *Of the 14 million or so software professionals around the world, many
> know of the existence of the UML yet only a modest percent use (about
> 7%) the UML on a daily basis*. (Grady Booch, 2002)

Un [estudio reciente](http://oro.open.ac.uk/35805/8/UMLinpractice8.pdf) revel√≥ que un 30% de profesionales usa UML, aunque lo hacen muy poco a lo largo de un desarrollo.

En palabras de Grady Booch:

> *The UML should be used to reason about alternatives. Put up some
> diagrams. Throw some use cases against it. Throw away those diagrams
> then write some code against you best decision.
> When we began with the UML, we never intended it to become a
> programming language. We never got the notation for collaborations right.
> Component and deployment diagrams needed more maturing. The UML
> metamodel became grossly bloated, because of the drive to model driven
> development. I think that complexity was an unnecessary mistake.
> Seriously, you need about 20% of the UML to do 80% of the kind of design
> you might want to do in a project ‚Äì agile or not ‚Äì but use the UML with a very
> light touch: use the notation to reason about a system, to communicate your
> intent to others‚Ä¶and then throw away most of your diagrams.*

Es decir, solo debemos usar diagramas para aquellas cosas sobre las que no se puede razonar sobre el c√≥digo.

### Modelos UML m√°s usados

- ~~Diagramas de casos de uso para requisitos.~~ (En desuso)

- Modelo de clases del dominio: **Diagramas de clases**

- M√°quinas de estado: **Diagramas de estado**

- Diagramas de interacci√≥n (principalmente para la documentaci√≥n)

- Diagramas de actividades (workflows de procesos de negocio, herramientas BPMN)

## Modelado estructural: diagrama de clases <a name="Punto2"></a>

En un modelado estructural se describen los tipos de objetos de un sistema y las relaciones que existen entre ellos.

- Clases, interfaces, relaciones de dependencia, realizaci√≥n, generalizaci√≥n y asociaci√≥n.

> Un diagrama de clases es una representaci√≥n gr√°fica de un modelo estructural.

Exiten diferentes usos para un diagrama de clases: para un modelo <u>conceptual</u>, para un modelo de clases del <u>dise√±o</u> o de la <u>implementaci√≥n</u>.

Ejemplos de diagramas de clases:

![](assets/ejemplo_diagrama_clases1.png)

![](assets/ejemplo_diagrama_clases2.png)

### Clase

Para representar a una clase dibujaremos un rect√°ngulo con 3 divisiones horizontales. En la primera pondremos el nombre de la clase, el la segunda divisi√≥n pondremos sus atributos, por √∫ltimo, en la tercera pondremos sus operaciones. Adem√°s, aquellas clases o m√©todos que sean abstractos ir√°n en cursiva, mientras que las variables y los m√©todos de clase ir√°n subrayados.

<img title="" src="assets/ejemplo_clase_1.png" alt="" width="188"><img title="" src="assets/ejemplo_clase_2.png" alt="" width="177"><img title="" src="assets/ejemplo_clase_3.png" alt="" width="182">

### Atributos

Para representar a los atributos de una clase, debemos seguir la siguiente notaci√≥n:

**`[visibilidad] nombre [:tipo] ['['multiplicidad']']`**

Pudiendo ser la visibilidad:

- p√∫blica (+) --> Pueden verlo todas las clases

- protegida (#) --> Pueden verlo todas las clases de ese paquete y las clases hijas de la clase a la que pertenece el atributo.

- a nivel de paquete (~) --> Pueden verlo todas las clases de ese paquete

- privada (-) --> Solo puede verlo la clase a la que pertenece el atributo.

### Operaciones

Para representar a las operaciones de una clase, debemos seguir la siguiente notaci√≥n:

**`[visibilidad] nombre ['('lista_par√°metros_')'][:tipo_retorno]`**

Pudiendo representarse la visibilidad de la misma forma que con los atributos. Los par√°metros que conforman la lista de par√°metros ir√°n separados por comas.

### Ejemplos de Atributos y Operaciones

#### Ejemplo 1:

```mermaid
classDiagram
¬†¬†¬†¬†direction DT
    class Coche{
        +km: int
        -matricula
        #126;precio
        +acelerar() int 
    }

    class abstractVeh√≠culo{
¬†¬†¬†¬†¬†¬†¬†¬†<<abstract>>
        #pi: float = 3.14
    }

    Coche --> abstractVeh√≠culo
    Moto --> abstractVeh√≠culo
```

**Nota:** Al ser Coche y Moto hijas de veh√≠culo, ambas flechas pueden combinarse en una sola, es decir, sale una flecha de cada una de las clases, y se unifican todas en una sola que llega a Veh√≠culo.

#### Ejemplo 2:

C√≥digo:

```java
public class Canguro implements Saltador{
    public int id;
    private String nombre;

    public Canguro (String n){
        nombre = n;
    }

    public void saltar(){
        System.out.println("SALTO");
    }
}


public interface Saltador{
    public void saltar();
}
```

Diagrama:

```mermaid
classDiagram
¬†¬†¬†¬†direction LR
    class Saltador{
¬†¬†¬†¬†¬†¬†¬†¬†<<interface>>
        +saltar()
    }

    class Canguro {
        +id: int
        -nombre: String
        +Canguro()
        +saltar()
    }

    Saltador <.. Canguro
```

### Relaciones

![](assets/relaciones_ejemplo1.png)

- **Dependencia**: En este tipo de relaciones, un cambio en la especificaci√≥n de un elemento afecta a otro elemento. <u>No</u> se utiliza en los diagramas de clases para relacionar objetos del dominio.

```mermaid
classDiagram
¬†¬†¬†¬†direction LR
¬†¬†¬†¬†class PlanDeCurso{
    ¬†¬†¬†¬†+a√±adir(c: Curso)
¬†¬†¬†¬†¬†¬†¬†¬†+eliminar(c: Curso)¬†¬†¬†¬†
¬†¬†¬†¬†}

¬†¬†¬†¬†PlanDeCurso --> Curso
```

- **Generalizaci√≥n**: Se corresponde con las relaciones *"Es un tipo de..."*. En el caso de un modelo de dise√±o o implementaci√≥n, denota una relaci√≥n de *<u>herencia</u>*.

```mermaid
classDiagram
¬†¬†¬†¬†CuentaAhorro --|> Cuenta
¬†¬†¬†¬†CuentaCorriente --|> Cuenta

¬†¬†¬†¬†TextWindow --|> Window
¬†¬†¬†¬†BoxDialog --|> Window
```

**Nota**: Igual que se ha visto antes, dos o m√°s relaciones con un mismo destino pueden juntarse en una sola l√≠nea.

- **Asociaci√≥n**: Es una relaci√≥n estructural que especifica que los objetos de un tipo est√°n conectados con los de otro tipo. Este tipo de relaci√≥n es el que se vi√≥ en el [MER](https://es.wikipedia.org/wiki/Modelo_entidad-relaci√≥n) durante la asignatura del segundo curso: Bases de Datos.
  En la asociaci√≥n encontramos la <u>multiplicidad</u>, que consiste en representar la cantidad de veces que una entidad puede repetirse en una relaci√≥n. Se representa `m√≠nimo..m√°ximo`.

```mermaid
classDiagram
    direction LR
    class Empleado{
        -nif
        -salario
    }

    class Empresa{
        -nombre
        -cif
    }

    Empleado "1..*" -- "1" Empresa
```

¬†¬†¬†¬†Las asociaciones son **bidireccionales**, pero es posible restringir la navegaci√≥n de ¬†¬†¬†¬†una asociaci√≥n a una sola direcci√≥n a√±adiendo una <u>flecha</u>, de esta manera se ¬†¬†¬†¬†determina si una clase de un extremo de la asociaci√≥n tiene *conocimiento* de la clase ¬†¬†¬†¬†del otro extremo.
¬†¬†¬†¬†La asociaci√≥n se utiliza en diagramas de dise√±o e implementaci√≥n.

```java
class Pedido{...
    private ArrayList<ItemPedido> items;
    private Date fecha;
    private boolean esCompleto;
}

class ItemPedido{...
    private Producto producto;
    private int cantidad;
...}

class Producto{...
    private Money precio;
    private String descripcion;
}
```

```mermaid
classDiagram
¬†¬†¬†¬†direction LR
¬†¬†¬†¬†class Pedido{
    ¬†¬†¬†¬†-fecha: Date
¬†¬†¬†¬†¬†¬†¬†¬†-esCompleto: boolean
¬†¬†¬†¬†}

¬†¬†¬†¬†class ItemPedido{
    ¬†¬†¬†¬†-cantidad: int
¬†¬†¬†¬†}


¬†¬†¬†¬†class Producto{
    ¬†¬†¬†¬†-precio: Money
¬†¬†¬†¬†¬†¬†¬†¬†-descripcion: String
¬†¬†¬†¬†}

¬†¬†¬†¬†Pedido "1" --> "1..*" ItemPedido : contiene
¬†¬†¬†¬†ItemPedido "*" --> "1" Producto : describe
```

- **Agregaci√≥n**: Es un caso especial de la asociaci√≥n que expresa la relaci√≥n <u>parte-de</u>: *un objeto es parte de otro objeto (agregado)*

```mermaid
classDiagram
¬†¬†¬†¬†direction LR
¬†¬†¬†¬†Documento o-- Capitulo : consta de
¬†¬†¬†¬†TPV o-- LectorC√≥digo : meteDinero
¬†¬†¬†¬†TPV o-- Caj√≥n : lee c√≥digos
```

- **Composici√≥n**: Es un tipo especial de agregaci√≥n.
  
  - Una parte pertenece a un √∫nico agragado (<u>exclusividad</u>)
  
  - Si se elimina un agregado, se eliminan todas sus partes (<u>dependencia</u>)
  
  Una parte se puede a√±adir/eliminar en cualquier instante.

<img title="" src="assets/ejemplo_agregado.png" alt="" data-align="center" width="586">

- **Realizaci√≥n**: Especifica que una clase implementa una interfaz.

> Una <u>interfaz</u> es una colecci√≥n de operaciones que especifican los servicios de una clase o componente. Una interfaz permite separar la especificaci√≥n de la implementaci√≥n.

```mermaid
classDiagram
¬†¬†¬†¬†direction LR
¬†¬†¬†¬†class ICollection{
¬†¬†¬†¬†¬†¬†¬†¬†<<interface>>
    ¬†¬†¬†¬†+add()
¬†¬†¬†¬†¬†¬†¬†¬†+remove()
¬†¬†¬†¬†¬†¬†¬†¬†+contains()¬†¬†¬†¬†
¬†¬†¬†¬†}

¬†¬†¬†¬†ICollection <|-- List
¬†¬†¬†¬†
```

¬†¬†¬†¬†¬†¬†¬†¬†Las interfaces tambi√©n pueden representarse haciendo uso de la notaci√≥n 

¬†¬†¬†¬†¬†¬†¬†¬†*<u>lollipop</u>*:

<img title="" src="assets/ejemplo_interfaz_lollipop.png" alt="" data-align="center" width="363">

## Modelado del comportamiento: Diagramas de Interacci√≥n <a name="Punto3"></a>

- Los<u> diagramas de interacci√≥n</u> describen c√≥mo los objetos colaboran entre s√≠ para realizar cierta actividad (lo veremos en TDS):
  
  - Diagramas de <mark>Secuencia</mark> y Diagramas de Colaboraci√≥n o <mark>Comunicaci√≥n</mark>

- M√°quinas de estado (las veremos en PDS):
  
  - Diagramas de estado
  
  - Diagramas de actividades

#### Diagramas de Interacci√≥n: Definiciones

- **Interacci√≥n**: Se dice del comportamiento que comprende un conjunto de mensajes intercambiados entre un conjunto de <u>l√≠neas de vida</u> (o a trav√©s de un <u>enlace</u>) para lograr un prop√≥sito.

- **Mensaje**: Consiste en una especificaci√≥n de una particular comunicaci√≥n entre l√≠neas de vida de una interacci√≥n que transmite informaci√≥n, con la expectativa de desencadenar una actividad.

- **L√≠nea de vida**: Son el objeto y la l√≠nea de tiempo que marca su existencia (diagramas de secuencia) o enlace (diagramas de comunicaci√≥n).

<img title="" src="assets/clases_e_instancias_UML.png" alt="" width="451" data-align="center">

- Un **enlace** es una instancia de una asociaci√≥n. Es un camino por el cual se env√≠a un mensaje.

<img title="" src="assets/ejemplo_enlace.png" alt="" data-align="center" width="513">

El siguiente diagrama de clases:

```mermaid
classDiagram
¬†¬†¬†¬†Cliente <-- Cuenta
¬†¬†¬†¬†Cuenta o-- Tarjeta
¬†¬†¬†¬†Cuenta o-- Transacci√≥n
¬†¬†¬†¬†Reintegro --o Transacci√≥n
¬†¬†¬†¬†Ingreso --o Transacci√≥n
```

Podr√≠a dar lugar al siguiente diagrama de objetos:

```mermaid
classDiagram
¬†¬†¬†¬†class Cuenta{
    ¬†¬†¬†¬†<<:Cuenta>>
        id = 3333444
¬†¬†¬†¬†¬†¬†¬†¬†saldo = 1000000
¬†¬†¬†¬†}

¬†¬†¬†¬†class Cliente{
        <<:Cliente>>
    ¬†¬†¬†¬†dni = 12345678
¬†¬†¬†¬†¬†¬†¬†¬†nombre = JJGM
¬†¬†¬†¬†}

¬†¬†¬†¬†class Tarjeta{
        <<:Tarjeta>>
    ¬†¬†¬†¬†Fecha: 09/2011
¬†¬†¬†¬†}

¬†¬†¬†¬†class Reintegro{
        <<:Reintegro>>
    ¬†¬†¬†¬†cantidad = 100
¬†¬†¬†¬†}

¬†¬†¬†¬†class Integro{
        <<:Integro>>
    ¬†¬†¬†¬†cantidad = 200
¬†¬†¬†¬†}

¬†¬†¬†¬†Cliente <-- Cuenta
¬†¬†¬†¬†Tarjeta --* Cuenta
¬†¬†¬†¬†Reintegro --* Cuenta
¬†¬†¬†¬†Integro --* Cuenta
```

### Diagramas de Secuencia

Est√°n formados por:

- L√≠neas de vida

- Focos de control o activaci√≥n

- Mensajes: a instancias o de creaci√≥n

- Mensaje self

- Informaci√≥n de control: condiciones y marcas de iteraci√≥n

- Indicar el objeto devuelto por el mensaje: return (a√±adirlos solo cuando ayuden a clarificar la interacci√≥n)

<img title="" src="assets/ejemplo_diagramas_secuencia.png" alt="" width="547" data-align="center">

#### Tipos de mensajes

- Simple: metodo(arg). Ej: `preparar()`, `addPedido(p)`

- Creaci√≥n de objetos: `<<create>>`

- Destrucci√≥n de objetos: `<<destroy>>`

- Asignaci√≥n: v:=m√©todo(arg). Ej: `hayStock := eliminar()`

Adem√°s, en UML 2.0 se incorporan los siguientes mensajes en diagramas de comunicaci√≥n:

- Condici√≥n: [condicion] metodo(arg). Ej: `[premium] saludo()`

- Iteraci√≥n: * metodo(arg), [1..n] metodo(arg). Ej: `*enviarPedido()`

La numeraci√≥n puede ser jer√°rquica, secuencial, o ninguna.

```mermaid
sequenceDiagram
¬†¬†¬†¬†activate GUIPedido
¬†¬†¬†¬†GUIPedido ->> ControladorPedidos : preparar()
¬†¬†¬†¬†activate ControladorPedidos
¬†¬†¬†¬†ControladorPedidos ->> Pedido : preparar()
¬†¬†¬†¬†activate Pedido
¬†¬†¬†¬†Pedido ->> LineaPedido : *preparar()
¬†¬†¬†¬†activate LineaPedido
¬†¬†¬†¬†LineaPedido ->> Item : hayStock:=check()
¬†¬†¬†¬†activate Item
¬†¬†¬†¬†deactivate Item
¬†¬†¬†¬†LineaPedido ->> Item : [hayStock] eliminar()
¬†¬†¬†¬†activate Item
¬†¬†¬†¬†Item ->> Item : pedir:=checkPedir()
¬†¬†¬†¬†activate Item
¬†¬†¬†¬†deactivate Item
¬†¬†¬†¬†Item ->> ItemPedido : [pedir]<<create>>
¬†¬†¬†¬†Item -->> LineaPedido : 
¬†¬†¬†¬†deactivate Item
¬†¬†¬†¬†LineaPedido ->> ItemEntregado : [hayStock]<<create>>
¬†¬†¬†¬†deactivate LineaPedido
¬†¬†¬†¬†deactivate Pedido
¬†¬†¬†¬†deactivate ControladorPedidos
¬†¬†¬†¬†deactivate GUIPedido
```

#### Foco de control o activaci√≥n

El foco de control es un rect√°ngulo que representa el tiempo durante el que un objeto est√° activo ejecutando una acci√≥n:

```mermaid
sequenceDiagram
¬†¬†¬†¬†activate Objeto
¬†¬†¬†¬†Objeto ->> Objeto : mensaje
¬†¬†¬†¬†deactivate Objeto
```

### Diagrama de Colaboraci√≥n o Comunicaci√≥n

<img title="" src="assets/ejemplo_diagrama_colaboracion.png" alt="" data-align="center" width="588">

```mermaid
stateDiagram
    direction LR
¬†¬†¬†¬†G : GUIPedido
¬†¬†¬†¬†C : ControladorPedidos
¬†¬†¬†¬†P : Pedido
¬†¬†¬†¬†LP : LineaPedido
¬†¬†¬†¬†I : Item
¬†¬†¬†¬†IP : ItemPedido
¬†¬†¬†¬†IE : ItemEntregado

¬†¬†¬†¬†G --> C : 1. preparar()
¬†¬†¬†¬†C --> P : 2. preparar()
¬†¬†¬†¬†P --> LP : 3. *preparar()
    note right of P
¬†¬†¬†¬†¬†¬†¬†¬†4. hayStock=check()
¬†¬†¬†¬†¬†¬†¬†¬†5. [hayStock] eliminar()
¬†¬†¬†¬†end note
¬†¬†¬†¬†LP --> I : 6. pedir=checkPedir()
¬†¬†¬†¬†I --> I
¬†¬†¬†¬†I --> IP : 7. [pedir] '<<'create'>>'
¬†¬†¬†¬†LP --> IE : 8. [hayStock] '<<'create'>>'
```

<img src="assets/mermaid_statediagram1_prerendered.png" title="" alt="" data-align="center">

#### Diagrama de Secuencia vs. Diagrama de Colaboraci√≥n

<u>Sencuencia</u>:

<img title="" src="assets/secuencia_vs_control-Diagrama_Secuencia.png" alt="" data-align="center" width="521">

**Nota**: El `<<destroy>>` no lo representaremos dada su inexistencia en Java.

<u>Colaboraci√≥n</u>:

<img title="" src="assets/secuencia_vs_control-Diagrama_Control.png" alt="" data-align="center" width="525">

Utilizaremos el diagrama de secuencia cuando nos interese que se vea de forma sencilla el orden de los mensajes. Si lo que deseamos es ver de forma clara los objetos que participan en la interacci√≥n y los mensajes que se env√≠an, entonces interesa usar el diagrama de colaboraci√≥n.

El punto negativo de los diagramas de secuencia es su longitud, mientras que en los de colaboraci√≥n es la posible dificultad a la hora de encontrar un mensaje por su numeraci√≥n.

### Operadores de Control (<span style="color:red">NO</span> recomendado)

En los diagramas de secuencia se pueden usar operadores de control para agrupar trozos de la secuencia:

- Ejecuci√≥n opcional (opt): El cuerpo se ejecuta si se cumple una condici√≥n.

- Ejecuci√≥n condicional (alt): El cuerpo se divide en varias regiones, cada una con una condici√≥n asociada. Se ejecuta el cuerpo de la regi√≥n cuya condici√≥n se satisface.

- Ejecuci√≥n paralela (par): El cuerpo se divide en varias regiones. Cada regi√≥n representa una computaci√≥n paralela. Se ejecuta de forma paralela el cuerpo de cada regi√≥n.

- Ejecuci√≥n iterativa (loop): El cuerpo se ejecuta mientras se cumple una condici√≥n.

- Ejecuci√≥n referencia (ref): El cuerpo hace referencia a otra interacci√≥n.

<img title="" src="assets/ejemplo_operadores_control.png" alt="" data-align="center" width="572">

<span style="color: red">No se recomienda</span> usarlos porque estar√≠amos *programando* con UML.

### Numeraci√≥n secuencial

En los diagramas de comunicaci√≥n, el uso de la numeraci√≥n secuencial puede provocar confusi√≥n, ya que pueden interpretarse de maneras distintas.

Por ejemplo, el siguiente diagrama:

<img title="" src="assets/problema_numeracion_secuencial.png" alt="" data-align="center" width="490">

Podr√≠a tener las siguientes interpretaciones como diagrama de secuencia:

<img title="" src="assets/problema_numeracion_secuencial-posibilidad_1_2.png" alt="" data-align="center" width="492">

<img title="" src="assets/problema_numeracion_secuencial-posibilidad_3.png" alt="" width="490" data-align="center">

**Nota**: Hay un error en esta √∫ltima imagen, lo correcto es indicar que el flujo de ejecuci√≥n de m2() abarca tambi√©n a m3() y m4().

### Numeraci√≥n jer√°rquica

La soluci√≥n es usar una numeraci√≥n jer√°rquica:

![](assets/problema_numeracion_secuencial-numeracion_jerarquica.png)

En la numeraci√≥n jer√°rquica agrupan en subgrupos los mensajes: 1, 1.1, 1.2, 2, 2.1, 3...

## Patrones GRASP <a name="Punto4"></a>

Los patrones GRASP describen los principios b√°sicos de asignaci√≥n de responsabilidades a clases. Distribuir responsabilidades es la parte m√°s dif√≠cil del dise√±o orientado a objetos, es por ello que esta fase es la que consume la mayor parte del tiempo.

Existen los siguientes patrones GRASP:

- <u>Experto, Creador, Controlador</u>

- Bajo Acoplamiento y Alta Cohesi√≥n

- Polimorfismo y Proteger variaci√≥n

### Responsabilidades y M√©todos

> Una responsabilidad se implementa mediante uno o m√°s m√©todos y puede asignarse a varias clases seg√∫n la granularidad (tama√±o).

Cuando se crea una clase, esa clase tiene un contrato u obligaci√≥n, que puede dividirse en dos categor√≠as:

- Conocer
  
  - Datos encapsulados privados.
  
  - Existencia de objetos conectados.
  
  - Datos derivados o calculados.

- Hacer
  
  - Algo √©l mismo, como crear un objeto o realizar un c√°lculo.
  
  - Iniciar una acci√≥n en otros objetos.
  
  - Controlar y coordinar actividades en otros objetos.

Los <u>diagramas de interacci√≥n</u> muestran elecciones en la asignaci√≥n de responsabilidades.

<img title="" src="assets/ejemplo_responsabilidades-de-una-clase.png" alt="" data-align="center" width="935">

### Experto

Es el patr√≥n m√°s importante de todos, ya que ayuda a decidir en qu√© clase debemos colocar cada m√©todo.

> ¬øC√≥mo se asignan responsabilidades?
> 
> > *Se debe asignar una responsabilidad a la clase que tiene la informaci√≥n necesaria para cumplimentarla.*

El objetivo es distribuir las responsabilidades de forma homog√©nea, evitando crear clases *dios* (es decir, una clase que reuna todos los m√©todos).

Los beneficios de seguir el patr√≥n experto son: la conservaci√≥n de la encapsulaci√≥n ([bajo acoplamiento](#bajoAcoplamiento)), y una [alta cohesi√≥n](#altaCohesi√≥n) (clases m√°s ligeras).

#### Ejemplo 1

Dado el siguiente diagrama de clases, ¬øqui√©n es el responsable de conocer el total de una venta?

```mermaid
classDiagram
¬†¬†¬†¬†direction LR
¬†¬†¬†¬†class Venta{
    ¬†¬†¬†¬†-fecha
¬†¬†¬†¬†¬†¬†¬†¬†-nota
¬†¬†¬†¬†}

¬†¬†¬†¬†class LineaVenta{
    ¬†¬†¬†¬†-cantidad
¬†¬†¬†¬†}

¬†¬†¬†¬†class Producto{
    ¬†¬†¬†¬†-descripcion
¬†¬†¬†¬†¬†¬†¬†¬†-precio
¬†¬†¬†¬†¬†¬†¬†¬†-codigo
¬†¬†¬†¬†}

¬†¬†¬†¬†Venta "1..1" -- "1..*" LineaVenta : contiene
¬†¬†¬†¬†LineaVenta "1" -- "0..*" Producto : descrita por
```

- [ ] Venta

- [ ] LineaVenta

- [ ] Producto

Lo intuitivo tal vez ser√≠a programar:

```java
public double getTotal(){
    double total = 0.0;
    for(LineaVenta lv : lineasVenta){
        double cant = lv.getCantidad();
        Producto pr = lv.getProducto();
        total += cant*pr.getPrecio();       
    }
    return total;
}
```

Pero entonces estar√≠amos violando el patr√≥n experto, representado con un diagrama de secuencia ver√≠amos esto:

```mermaid
sequenceDiagram
¬†¬†¬†¬†activate GUIRealizarCompra
¬†¬†¬†¬†GUIRealizarCompra ->> Venta : 1. getTotal()
¬†¬†¬†¬†activate Venta
¬†¬†¬†¬†Venta ->> LineaVenta : 2. getCantidad()
¬†¬†¬†¬†activate LineaVenta
¬†¬†¬†¬†Venta ->> LineaVenta : 3. getProducto()
¬†¬†¬†¬†Venta ->> Producto : 4. getPrecio()
¬†¬†¬†¬†activate Producto
¬†¬†¬†¬†deactivate Producto
¬†¬†¬†¬†deactivate LineaVenta
¬†¬†¬†¬†deactivate Venta
¬†¬†¬†¬†deactivate GUIRealizarCompra
```

Para no violar el experto, buscamos el siguiente diagrama:

```mermaid
sequenceDiagram
¬†¬†¬†¬†activate GUIRealizarCompra
¬†¬†¬†¬†GUIRealizarCompra ->> Venta : getTotal()
¬†¬†¬†¬†activate Venta
¬†¬†¬†¬†Venta ->> LineaVenta : *st = getSubtotal()
¬†¬†¬†¬†activate LineaVenta
¬†¬†¬†¬†LineaVenta ->> producto: pr=  getPrecio()
¬†¬†¬†¬†deactivate LineaVenta
¬†¬†¬†¬†deactivate Venta
¬†¬†¬†¬†deactivate GUIRealizarCompra
```

Lo cual se corresponde con el siguiente c√≥digo, que <u>**no**</u> viola el patr√≥n experto:

```java
class Venta {..

    public double getTotal() {
        double total = 0.0;
        for (LineaVenta lv : lineasVenta)
            total = total + lv.getSubtotal());
        return total;
    }
}

class LineaVenta{..
    private int cantidad;
    private Producto producto;

    public double getSubtotal()
        return cantidad*producto.getPrecio();
}
```

#### Ejemplo 2

¬øQui√©n es el responsable de conocer todos los mensajes recibidos entre dos fechas?

```mermaid
classDiagram
¬†¬†¬†¬†direction LR
¬†¬†¬†¬†LectorCorreo *-- Buzon
¬†¬†¬†¬†Buzon *-- Carpeta
¬†¬†¬†¬†Carpeta *-- Mensaje
```

- [ ] LectorCorreo

- [ ] Buzon

- [ ] Carpeta

- [ ] Mensaje

Violando el experto, har√≠amos esto:

```
para cada mensaje m en cada carpeta c
    si f en rango [f1,f2]
        a√±adir al conjunto s
return s
```

Que se corresponde con:

```mermaid
sequenceDiagram
¬†¬†¬†¬†activate main
¬†¬†¬†¬†participant main
¬†¬†¬†¬†participant l as LectorCorreo
¬†¬†¬†¬†main ->> l : getMensajes(f1,f2)
¬†¬†¬†¬†activate l
¬†¬†¬†¬†l ->> Buzon : c = getCarpetas()
¬†¬†¬†¬†activate Buzon
¬†¬†¬†¬†deactivate Buzon
¬†¬†¬†¬†l ->> Carpeta : *m = getmensajes()
¬†¬†¬†¬†activate Carpeta
¬†¬†¬†¬†deactivate Carpeta
¬†¬†¬†¬†l ->> Mensaje : *f = getFecha()
¬†¬†¬†¬†activate Mensaje
¬†¬†¬†¬†deactivate Mensaje
¬†¬†¬†¬†l ->> Set : [f en rango] add()
¬†¬†¬†¬†activate Set
¬†¬†¬†¬†deactivate Set
¬†¬†¬†¬†deactivate l
¬†¬†¬†¬†deactivate main
```

Sin violar el experto har√≠amos:

```mermaid
sequenceDiagram
¬†¬†¬†¬†activate main
¬†¬†¬†¬†participant main
¬†¬†¬†¬†participant l as LectorCorreo
¬†¬†¬†¬†main ->> l : getMensajes(f1,f2)
¬†¬†¬†¬†activate l
¬†¬†¬†¬†l ->> Buzon : m = getMensajes(f1,f2)
¬†¬†¬†¬†activate Buzon
¬†¬†¬†¬†Buzon ->> Carpeta : *m = getmensajes()
¬†¬†¬†¬†activate Carpeta
¬†¬†¬†¬†Carpeta ->> Mensaje : *entreFechas(f1,f2)
¬†¬†¬†¬†activate Mensaje
¬†¬†¬†¬†deactivate Mensaje
¬†¬†¬†¬†deactivate Carpeta
¬†¬†¬†¬†deactivate Buzon
¬†¬†¬†¬†deactivate l
¬†¬†¬†¬†deactivate main
```

#### Ejemplo 3

¬øQui√©n es el responsable de conocer el n√∫mero de proyectos de cierto tipo realizados en una universidad en un rango de fechas?

```mermaid
classDiagram
    direction LR
¬†¬†¬†¬†class ControladorProyectos{
    ¬†¬†¬†¬†numProyectos()
¬†¬†¬†¬†}
¬†¬†¬†¬†class Universidad{
    ¬†¬†¬†¬†+getGrupos()
¬†¬†¬†¬†}
¬†¬†¬†¬†class CatalogoUniversidades{
    ¬†¬†¬†¬†+getUniversidad()
¬†¬†¬†¬†}
¬†¬†¬†¬†class GrupoInvestigacion{
    ¬†¬†¬†¬†+getproyectos()
¬†¬†¬†¬†}
¬†¬†¬†¬†class Proyecto{
    ¬†¬†¬†¬†+getFecha()
¬†¬†¬†¬†¬†¬†¬†¬†+getTipo()
¬†¬†¬†¬†}

¬†¬†¬†¬†ControladorProyectos --> Universidad : 
¬†¬†¬†¬†ControladorProyectos --> CatalogoUniversidades : 
¬†¬†¬†¬†Universidad "0..*" --* CatalogoUniversidades : 
¬†¬†¬†¬†GrupoInvestigacion "1..*" --* Universidad : 
¬†¬†¬†¬†Proyecto "0..*" --* GrupoInvestigacion 
```

Con violaci√≥n del experto har√≠amos:

```java
public class ControladorProyectos {...
    public int numProyectos(int id, int tipo, Date f1, Date f2) {
        int totalProyectos = 0;
        Universidad uni = CatalogoUniversidades.getUniversidad(id);
        Collection<Grupo> grupos = uni.getGrupos();
        for (Grupo grupo: grupos) {
            Collection<Proyecto> proyectos = grupo.getProyectos();
            for (Proyecto proyecto : proyectos){
                fechaProyecto = proyecto.getFecha();
                if((fechaProyecto.before(f2)) &&(fechaProyecto.after(f1))
                  ¬†¬†¬†¬†&& (tipo == proyecto.getTipo()))
                    totalProyectos= totalProyectos + 1;
                }
        }
        return totalProyectos;
    }
}
```

Lo que dar√≠a lugar al siguiente diagrama de colaboraci√≥n:

<img title="" src="assets/violacion_experto_ejemplo3.png" alt="" data-align="center" width="534">

Que en diagrama de secuencia ser√≠a:

```mermaid
sequenceDiagram
¬†¬†¬†¬†participant g as GUIResponsable
¬†¬†¬†¬†participant cp as ControladorProyectos
¬†¬†¬†¬†participant cu as ControladorUniversidades
¬†¬†¬†¬†participant u as Universidad
¬†¬†¬†¬†participant gi as GrupoInvestigacion
¬†¬†¬†¬†participant p as Proyecto
¬†¬†¬†¬†
¬†¬†¬†¬†activate g
¬†¬†¬†¬†g ->> cp : 1. numProyectos()
¬†¬†¬†¬†activate cp
¬†¬†¬†¬†cp ->> cu : 2. getUniversidad()
¬†¬†¬†¬†activate cu
¬†¬†¬†¬†deactivate cu
¬†¬†¬†¬†cp ->> u : 3. getGrupos()
¬†¬†¬†¬†activate u
¬†¬†¬†¬†deactivate u
¬†¬†¬†¬†cp ->> gi : 4. getProyectos()
¬†¬†¬†¬†activate gi
¬†¬†¬†¬†deactivate gi
¬†¬†¬†¬†cp ->> p : 5. getFecha()
¬†¬†¬†¬†activate p
¬†¬†¬†¬†cp ->> p : 6. getTipo()
    deactivate p
¬†¬†¬†¬†deactivate cp
¬†¬†¬†¬†deactivate g
```

Sin violar el experto:

```java
public class ControladorProyectos {...
    public int numProyectos(int id, int tipo, Date f1, Date f2){
        Universidad uni = CatalogoUniversidades.getUniversidad(id);
        return uni.numProyectos(tipo, f1, f2);
    }
}
public class Universidad {...
    private Collection<GrupoInvestigacion> grupos;
    public int numProyectos(int tipo, Date f1, Date f2) {
        int total = 0;
        for (Grupo grupo: grupos)
            total = total + grupo.numProyectos(tipo, f1, f2);
        return total;
    }
}
public class GrupoInvestigacion {...
    private List<Proyecto> proyectos;
    public int numProyectos(int tipo, Date f1, Date f2) {
        int total = 0;
        for (Proyecto proyecto : proyectos){
            if ((proyecto.esTipo(tipo)) &&
                   (proyecto.estaEntre(f1, f2)))
                total = total + 1;
¬†¬†¬†¬†¬†¬†¬†¬†}
¬†¬†¬†¬†¬†¬†¬†¬†return total;
¬†¬†¬†¬†}
}
public class Proyecto {...
¬†¬†¬†¬†private Date fecha;
¬†¬†¬†¬†private int tipo;
¬†¬†¬†¬†public boolean esTipo(int tipo) {
¬†¬†¬†¬†¬†¬†¬†¬†return (this.tipo == tipo);
¬†¬†¬†¬†}
¬†¬†¬†¬†public boolean estaEntre(Date f1, Date f2) {
¬†¬†¬†¬†¬†¬†¬†¬†return ((fecha.after(f1)) && (fecha.before(f2)));
¬†¬†¬†¬†}
}
```

Cuyo diagrama de colaboraci√≥n es:

<img title="" src="assets/sin-violacion_experto_ejemplo3.png" alt="" data-align="center" width="623">

Que en diagrama de secuencia ser√≠a:

```mermaid
sequenceDiagram
¬†¬†¬†¬†participant g as GUIResponsable
¬†¬†¬†¬†participant cp as ControladorProyectos
¬†¬†¬†¬†participant cu as ControladorUniversidades
¬†¬†¬†¬†participant u as Universidad
¬†¬†¬†¬†participant gi as GrupoInvestigacion
¬†¬†¬†¬†participant p as Proyecto
¬†¬†¬†¬†
¬†¬†¬†¬†
¬†¬†¬†¬†g ->> cp : 1. numProyectos()
¬†¬†¬†¬†activate g
¬†¬†¬†¬†activate cp
¬†¬†¬†¬†cp ->> cu : 2. getUniversidad()
¬†¬†¬†¬†activate cu
¬†¬†¬†¬†deactivate cu
¬†¬†¬†¬†cp ->> u : 3. numProyectos()
¬†¬†¬†¬†activate u
¬†¬†¬†¬†u ->> gi : 4. numProyectos()
¬†¬†¬†¬†activate gi
¬†¬†¬†¬†gi ->> p : 5. estaEntre()
¬†¬†¬†¬†activate p
¬†¬†¬†¬†gi ->> p : 6. esTipo()
¬†¬†¬†¬†deactivate p
¬†¬†¬†¬†deactivate gi
¬†¬†¬†¬†deactivate u
¬†¬†¬†¬†deactivate cp
¬†¬†¬†¬†deactivate g
```
